.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.01 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Open::This 3pm"
.TH Open::This 3pm 2025-10-28 "perl v5.38.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH DESCRIPTION
.IX Header "DESCRIPTION"
This module powers the ot command line script, which tries to do the right
thing when opening a file.  Imagine your \f(CW$ENV{EDITOR}\fR is set to \f(CW\*(C`vim\*(C'\fR.
(This should also work for \f(CW\*(C`emacs\*(C'\fR and \f(CW\*(C`nano\*(C'\fR.)  The following examples
demonstrate how your input is translated when launching your editor.
.PP
.Vb 2
\&    ot Foo::Bar # vim lib/Foo/Bar.pm
\&    ot Foo::Bar # vim t/lib/Foo/Bar.pm
.Ve
.PP
Imagine this module has a \f(CW\*(C`sub do_something\*(C'\fR at line 55.
.PP
.Vb 1
\&    ot "Foo::Bar::do_something()" # vim +55 lib/Foo/Bar.pm
.Ve
.PP
Or, when copy/pasting from a stack trace.  (Note that you do not need quotes in
this case.)
.PP
.Vb 1
\&    ot Foo::Bar line 36 # vim +36 lib/Foo/Bar.pm
.Ve
.PP
Copy/pasting a \f(CW\*(C`git\-grep\*(C'\fR result.
.PP
.Vb 1
\&    ot lib/Foo/Bar.pm:99 # vim +99 Foo/Bar.pm
.Ve
.PP
Copy/pasting a partial GitHub URL.
.PP
.Vb 1
\&    ot lib/Foo/Bar.pm#L100 # vim +100 Foo/Bar.pm
.Ve
.PP
Copy/pasting a full GitHub URL.
.PP
.Vb 2
\&    ot https://github.com/oalders/open\-this/blob/master/lib/Open/This.pm#L17\-L21
\&    # vim +17 lib/Open/This.pm
.Ve
.PP
Open a local file on the GitHub web site in your web browser.  From within a
checked out copy of https://github.com/oalders/open\-this
.PP
.Vb 1
\&    ot \-b Foo::Bar
.Ve
.PP
Open a local file at the correct line on the GitHub web site in your web
browser.  From within a checked out copy of
https://github.com/oalders/open\-this:
.PP
.Vb 2
\&    ot \-b Open::This line 50
\&    # https://github.com/oalders/open\-this/blob/master/lib/Open/This.pm#L50
.Ve
.SH "SUPPORTED EDITORS"
.IX Header "SUPPORTED EDITORS"
This code has been well tested with \f(CW\*(C`vim\*(C'\fR.  It should also work with \f(CW\*(C`nvim\*(C'\fR,
\&\f(CW\*(C`emacs\*(C'\fR, \f(CW\*(C`pico\*(C'\fR, \f(CW\*(C`nano\*(C'\fR and \f(CW\*(C`kate\*(C'\fR.  Patches for other editors are very
welcome.
.SH FUNCTIONS
.IX Header "FUNCTIONS"
.SS parse_text
.IX Subsection "parse_text"
Given a scalar value or an array of scalars, this function will try to extract
useful information from it.  Returns a hashref on success.  Returns undef on
failure.  \f(CW\*(C`file_name\*(C'\fR is the only hash key which is guaranteed to be in the
hash.
.PP
.Vb 2
\&    use Open::This qw( parse_text );
\&    my $parsed = parse_text(\*(Aqt/lib/Foo/Bar.pm:32\*(Aq);
\&
\&    # $parsed = { file_name => \*(Aqt/lib/Foo/Bar.pm\*(Aq, line_number => 32, }
\&
\&    my $with_sub_name = parse_text( \*(AqFoo::Bar::do_something()\*(Aq );
\&
\&    # $with_sub_name = {
\&    #     file_name     => \*(Aqt/lib/Foo/Bar.pm\*(Aq,
\&    #     line_number   => 3,
\&    #     original_text => \*(Aqt/lib/Foo/Bar.pm:32\*(Aq,
\&    #     sub_name      => \*(Aqdo_something\*(Aq,
\&    # };
.Ve
.SS to_editor_args
.IX Subsection "to_editor_args"
Given a scalar value, this calls \f(CWparse_text()\fR and returns an array of values
which can be passed at the command line to an editor.
.PP
.Vb 2
\&    my @args = to_editor_args(\*(AqFoo::Bar::do_something()\*(Aq);
\&    # @args = ( \*(Aq+3\*(Aq, \*(Aqt/lib/Foo/Bar.pm\*(Aq );
.Ve
.SS editor_args_from_parsed_text
.IX Subsection "editor_args_from_parsed_text"
If you have a \f(CW\*(C`hashref\*(C'\fR from the \f(CW\*(C`parse_text\*(C'\fR function, you can get editor
args via this function.  (The faster way is just to call \f(CW\*(C`to_editor_args\*(C'\fR
directly.)
.PP
.Vb 2
\&    my @args
\&        = editor_args_from_parsed_text( parse_text(\*(Aqt/lib/Foo/Bar.pm:32\*(Aq) );
.Ve
.SS maybe_get_url_from_parsed_text
.IX Subsection "maybe_get_url_from_parsed_text"
Tries to return an URL to a Git repository for a checked out file.  The URL
will be built using the \f(CW\*(C`origin\*(C'\fR remote and the name of the current branch.  A
line number will be attached if it can be parsed from the text.  This has only
currently be tested with GitHub URLs and it assumes you're working on a branch
which has already been pushed to your remote.
.PP
.Vb 2
\&    my $url = maybe_get_url_from_parsed_text( parse_text(\*(Aqt/lib/Foo/Bar.pm:32\*(Aq));
\&    # $url might be something like: https://github.com/oalders/open\-this/blob/master/lib/Open/This.pm#L32
.Ve
.SH "ENVIRONMENT VARIABLES"
.IX Header "ENVIRONMENT VARIABLES"
By default, \f(CW\*(C`ot\*(C'\fR will search your \f(CW\*(C`lib\*(C'\fR and \f(CW\*(C`t/lib\*(C'\fR directories for local
files.  You can override this via the \f(CW$ENV{OPEN_THIS_LIBS}\fR variable.  It
accepts a comma-separated list of libs.
.SH "VIM INTEGRATION"
.IX Header "VIM INTEGRATION"
If you're a \f(CW\*(C`vim\*(C'\fR user, you can use the following code to your \f(CW\*(C`.vimrc\*(C'\fR to
integrate \f(CW\*(C`ot\*(C'\fR directly with your editor.
.PP
.Vb 3
\&    " Thanks to D. Ben Knoble for getting histadd() to work:
\&    " https://vi.stackexchange.com/questions/34818/how\-to\-use\-histadd\-with\-a\-custom\-function/34819#34819
\&    nnoremap <leader>ot :call OT(input("ot: ", "", "file"))<cr>
\&
\&    " trim() requires vim 8
\&    " https://github.com/vim/vim/commit/295ac5ab5e840af6051bed5ec9d9acc3c73445de
\&    function! OT(fname)
\&        let res = system("ot \-\-editor vim \-\-print " . shellescape(trim(a:fname)))
\&        if v:shell_error
\&            echo "\en" . res
\&        else
\&            execute "e " res
\&        endif
\&        call histadd(\*(Aq:\*(Aq, printf(\*(Aqcall OT("%s")\*(Aq, escape(a:fname, \*(Aq"\e\*(Aq)))
\&    endfunction
.Ve
.PP
With the above code, you can enter <leader>ot and then enter your \f(CW\*(C`ot\*(C'\fR args
directly in \f(CW\*(C`vim\*(C'\fR. If the file is found, it will be opened in a buffer,
hopefully at the appropriate line and column number. An up to date copy of this
command should generally be available in my dotfiles repo as well:
<https://github.com/oalders/dot\-files/blob/main/vim/vimrc>.
